#! /usr/bin/python
# by pts@fazekas.hu at Thu Nov 28 22:09:47 CET 2019
#
# Simple Python 2.x tool to decrypt OpenPGP data encrypted with symmetric
# key (output of `gpg -c' and `gpg --symmetric'), crypto based on
# tinyveracrypt, only AES cipher is supported.
#
# OpenPGP is defined in https://tools.ietf.org/html/rfc4880
#

import struct
import sys

import tinyveracrypt


def yield_gpg_binary_packets(fread, c0=''):
  while 1:
    if not c0:
      c0 = fread(1)
    if not c0:
      break
    b, c0 = ord(c0), ''
    if not b & 128:
      raise ValueError('Tag bit 7 expected.')
    if b & 64:  # New-format packet.
      packet_type = b & 63
      if packet_type == 0:
        raise ValueError('Packet type must not be 0.')
      c = fread(1)
      if not c:
        raise ValueError('EOF in new packet size byte 0.')
      b = ord(c)
      if 224 + 9 <= b < 255:
        while 1:
          remaining, is_partial = 1 << (b & 31), True
          while remaining > 0:
            size = min(remaining, 8192)  # Avoid large partial packets.
            data = fread(size)
            if len(data) != size:
              raise ValueError('EOF in partial packet.')
            yield packet_type, is_partial, data
            remaining -= size
          c = fread(1)
          if not c:
            raise ValueError('EOF in after-partial size byte 0.')
          b = ord(c)
          if not 224 <= b < 255:
            break
      if b < 191:
        size = b
      elif b < 224:
        c = fread(1)
        if not c:
          raise ValueError('EOF in new packet size byte 1.')
        size = ((b - 192) << 8 | ord(c)) + 192
      elif b < 255:
        # >= 512 bytes needed.
        raise ValueError('First partial body too short.')
      else:
        c = fread(4)
        if len(c) < 4:
          raise ValueError('EOF in new packet size byte 5.')
        size, = struct.unpack('>L', c)
    else:  # Old-format packet.
      packet_type = (b & 63) >> 2
      if packet_type == 0:
        raise ValueError('Packet type must not be 0.')
      lt = b & 3
      if lt == 0:
        c = fread(1)
        if not c:
          raise ValueError('EOF in old packet size 0.')
        size = ord(c)
      elif lt == 1:
        c = fread(2)
        if len(c) < 2:
          raise ValueError('EOF in old packet size 1.')
        size, = struct.unpack('>H', c)
      elif lt == 2:
        c = fread(4)
        if len(c) < 4:
          raise ValueError('EOF in old packet size 2.')
        size, = struct.unpack('>L', c)
      elif lt == 3:
        raise ValueError('Indeterminate packet size not supported.')
      else:
        raise ValueError('Unknown old packet tag: %d' % lt)
    if size:
      if packet_type in (9, 11, 18):
        if size > 8192:
          remaining, is_partial = (size - 8192) & ~8191, True
          while remaining > 0:
            size2 = min(remaining, 8192)
            data = fread(size2)
            if len(data) != size2:
              raise ValueError('EOF in partial packet.')
            yield packet_type, is_partial, data
            remaining -= size2
            size -= size2
        assert 0 < size <= 8192
      elif size > 46:
        # We could easily handle megabytes, but the output of `gpg
        # --symmetric' just doesn't have such packets.
        raise ValueError('Packet size unusually large: type %d, size %d' %
                         (packet_type, size))
      data = fread(size)
      if len(data) < size:
        raise ValueError('EOF in packet, type %d' % packet_type)
      is_partial = False
      yield packet_type, is_partial, data


CRC24_TABLE = (
    0x000000, 0x864cfb, 0x8ad50d, 0x0c99f6, 0x93e6e1, 0x15aa1a, 0x1933ec,
    0x9f7f17, 0xa18139, 0x27cdc2, 0x2b5434, 0xad18cf, 0x3267d8, 0xb42b23,
    0xb8b2d5, 0x3efe2e, 0xc54e89, 0x430272, 0x4f9b84, 0xc9d77f, 0x56a868,
    0xd0e493, 0xdc7d65, 0x5a319e, 0x64cfb0, 0xe2834b, 0xee1abd, 0x685646,
    0xf72951, 0x7165aa, 0x7dfc5c, 0xfbb0a7, 0x0cd1e9, 0x8a9d12, 0x8604e4,
    0x00481f, 0x9f3708, 0x197bf3, 0x15e205, 0x93aefe, 0xad50d0, 0x2b1c2b,
    0x2785dd, 0xa1c926, 0x3eb631, 0xb8faca, 0xb4633c, 0x322fc7, 0xc99f60,
    0x4fd39b, 0x434a6d, 0xc50696, 0x5a7981, 0xdc357a, 0xd0ac8c, 0x56e077,
    0x681e59, 0xee52a2, 0xe2cb54, 0x6487af, 0xfbf8b8, 0x7db443, 0x712db5,
    0xf7614e, 0x19a3d2, 0x9fef29, 0x9376df, 0x153a24, 0x8a4533, 0x0c09c8,
    0x00903e, 0x86dcc5, 0xb822eb, 0x3e6e10, 0x32f7e6, 0xb4bb1d, 0x2bc40a,
    0xad88f1, 0xa11107, 0x275dfc, 0xdced5b, 0x5aa1a0, 0x563856, 0xd074ad,
    0x4f0bba, 0xc94741, 0xc5deb7, 0x43924c, 0x7d6c62, 0xfb2099, 0xf7b96f,
    0x71f594, 0xee8a83, 0x68c678, 0x645f8e, 0xe21375, 0x15723b, 0x933ec0,
    0x9fa736, 0x19ebcd, 0x8694da, 0x00d821, 0x0c41d7, 0x8a0d2c, 0xb4f302,
    0x32bff9, 0x3e260f, 0xb86af4, 0x2715e3, 0xa15918, 0xadc0ee, 0x2b8c15,
    0xd03cb2, 0x567049, 0x5ae9bf, 0xdca544, 0x43da53, 0xc596a8, 0xc90f5e,
    0x4f43a5, 0x71bd8b, 0xf7f170, 0xfb6886, 0x7d247d, 0xe25b6a, 0x641791,
    0x688e67, 0xeec29c, 0x3347a4, 0xb50b5f, 0xb992a9, 0x3fde52, 0xa0a145,
    0x26edbe, 0x2a7448, 0xac38b3, 0x92c69d, 0x148a66, 0x181390, 0x9e5f6b,
    0x01207c, 0x876c87, 0x8bf571, 0x0db98a, 0xf6092d, 0x7045d6, 0x7cdc20,
    0xfa90db, 0x65efcc, 0xe3a337, 0xef3ac1, 0x69763a, 0x578814, 0xd1c4ef,
    0xdd5d19, 0x5b11e2, 0xc46ef5, 0x42220e, 0x4ebbf8, 0xc8f703, 0x3f964d,
    0xb9dab6, 0xb54340, 0x330fbb, 0xac70ac, 0x2a3c57, 0x26a5a1, 0xa0e95a,
    0x9e1774, 0x185b8f, 0x14c279, 0x928e82, 0x0df195, 0x8bbd6e, 0x872498,
    0x016863, 0xfad8c4, 0x7c943f, 0x700dc9, 0xf64132, 0x693e25, 0xef72de,
    0xe3eb28, 0x65a7d3, 0x5b59fd, 0xdd1506, 0xd18cf0, 0x57c00b, 0xc8bf1c,
    0x4ef3e7, 0x426a11, 0xc426ea, 0x2ae476, 0xaca88d, 0xa0317b, 0x267d80,
    0xb90297, 0x3f4e6c, 0x33d79a, 0xb59b61, 0x8b654f, 0x0d29b4, 0x01b042,
    0x87fcb9, 0x1883ae, 0x9ecf55, 0x9256a3, 0x141a58, 0xefaaff, 0x69e604,
    0x657ff2, 0xe33309, 0x7c4c1e, 0xfa00e5, 0xf69913, 0x70d5e8, 0x4e2bc6,
    0xc8673d, 0xc4fecb, 0x42b230, 0xddcd27, 0x5b81dc, 0x57182a, 0xd154d1,
    0x26359f, 0xa07964, 0xace092, 0x2aac69, 0xb5d37e, 0x339f85, 0x3f0673,
    0xb94a88, 0x87b4a6, 0x01f85d, 0x0d61ab, 0x8b2d50, 0x145247, 0x921ebc,
    0x9e874a, 0x18cbb1, 0xe37b16, 0x6537ed, 0x69ae1b, 0xefe2e0, 0x709df7,
    0xf6d10c, 0xfa48fa, 0x7c0401, 0x42fa2f, 0xc4b6d4, 0xc82f22, 0x4e63d9,
    0xd11cce, 0x575035, 0x5bc9c3, 0xdd8538,
)


def crc24(data, crc=0xb704ce):
  if not isinstance(data, (str, buffer)):
    raise TypeError
  table = CRC24_TABLE
  for c in data:
    crc = (table[((crc >> 16) ^ ord(c)) & 0xff] ^ (crc << 8)) & 0x00ffffff
  return crc


def str_to_fread(data):
  if not isinstance(data, (str, buffer)):
    raise TypeError
  i_ary = [0]

  def fread(size):
    i = i_ary[0]
    result = data[i : i + size]
    i_ary[0] = i + len(result)
    return result

  return fread


def get_gpg_ascii_armor_fread(fread):
  import binascii  # For base64.

  def yield_data_chunks(_a2b=binascii.a2b_base64, _crc24=crc24):
    buf, is_in_header, crc = '\n', True, _crc24('')

    try:
      while 1:
        data = fread(512)  # Anything >= 1 works here.
        if not data:
          raise ValueError('EOF in GPG ASCII armor.')
        data = data.replace('\r', '')
        if not data:
          continue
        if is_in_header:  # Skip over header.
          if buf[-1:] == '\n' and data[0] == '\n':
            data, is_in_header = data[1:], False
          else:
            i = data.find('\n\n')
            if i >= 0:
              data, is_in_header = data[i + 2:], False
            else:
              buf = data[-1:]  # Keep last '\n', if any.
              continue
          buf = ''
        i = data.find('-')
        if i >= 0:
          buf += data[:i].replace('\n', '')
          data = data[i:]
          break
        buf += data.replace('\n', '')
        s = len(buf)
        if s > 12:
          t = (s - 9) & ~3  # Keep last 5 for checksum, keep 4 for last few bytes.
          i = buf.find('=')
          if 0 <= i < t:
            raise ValueError('Too much padding at end of GPG ASCII armor base64.')
          bdata, buf = _a2b(buf[:t]), buf[t:]
          crc = _crc24(bdata, crc)
          yield bdata
      if len(data) < 26:
        data += fread(26 - len(data))
      if not (data.startswith('-----END PGP MESSAGE-----') and data[25 : 26] in '\r\n'):
        raise ValueError('Bad end of GPG ASCII armor.')
      t = buf.rfind('=')
      if t <= 0:
        raise ValueError('Missing GPG ASCII armor checksum.')
      if len(buf) != t + 5:
        raise ValueError('GPG ASCII armor checksum must be 4 bytes.')
      expected_crc = _a2b(buf[t + 1:])
      expected_crc, = struct.unpack('>L', '\0' + expected_crc)
      if buf[t - 2 : t] == '==':
        i = t - 2
      elif buf[t - 1 : t] == '=':
        i = t - 1
      else:
        i = t
      if buf.find('=') != i:
        raise ValueError('Too much padding at end of GPG ASCII armor base64.')
      bdata = _a2b(buf[:t])
      crc = _crc24(bdata, crc)
      if crc != expected_crc:
        raise ValueError('GPG ASCII armor checksum mismatch.')
      if bdata:
        yield bdata
    except binascii.Error:
      raise ValueError('Bad GPG ASCII armor data base64.')

  return iter_to_fread(yield_data_chunks())


def yield_gpg_packets(fread):
  while 1:
    c = fread(1)
    if not c:
      raise ValueError('EOF before GPG data.')
    if not c.isspace():
      break
  if c == '-':
    data = fread(27)
    if not (len(data) == 27 and data.startswith('-----BEGIN PGP MESSAGE-----'[1:]) and data[26] in '\r\n'):
      raise ValueError('GPG ASCII armor expected.')
    fread = get_gpg_ascii_armor_fread(fread)
    c = fread(1)
    if not c:
      raise ValueError('Empty GPG ASCII armor data.')
  if c not in '\x8c\x8d\x8e\xc3':  # packet_type == 3 (SKESK).
    raise ValueError('Bad GPG symmetric encrypted data (SKESK packet expected).')
  for packet in yield_gpg_binary_packets(fread, c):
    yield packet


CIPHER_ALGOS = {
    #0: 'unencrypted',  # gpg(1) can't decrypt it either.
    7: 'aes-128',
    8: 'aes-192',
    9: 'aes-256',
}


# https://github.com/gpg/libgcrypt/blob/e5c4cf0efb8fd297963e6b4392ab98c41dbad536/src/gcrypt.h.in#L919
CIPHER_ALGOS_ALL = {
    0: 'unencrypted',  # gpg(1) can't decrypt it either.
    1: 'idea',
    2: '3des',
    3: 'cast5',  # With 128-bit key.
    4: 'blowfish',
    5: 'safer-sk128',
    6: 'des-sk',
    7: 'aes-128',
    8: 'aes-192',
    9: 'aes-256',
    10: 'twofish-256',
    301: 'rc4',  # 'arcfour'.
    302: 'des',  # Single-key, 56-bit DES.
    303: 'twofish-128',
    304: 'serpent-128',
    305: 'serpent-192',
    306: 'serpent-256',
    307: 'rfc2268-ron-40',
    308: 'rfc2268-ron-128',
    309: 'rfc4269-seed',
    310: 'camellia-128',
    311: 'camellia-192',
    312: 'camellia-256',
    313: 'salsa20',
    314: 'salsa20-r12',
    315: 'rfc-5830-gost',  # GOST 28147-89.
    316: 'chacha20',
}

KEYTABLE_SIZES = {
    7: 16,
    8: 24,
    9: 32,
}

HASH_ALGOS = {
    1: 'md5',
    2: 'sha1',
    3: 'ripemd160',
    8: 'sha256',
    9: 'sha384',
    10: 'sha512',
    11: 'sha224',
}

S2K_TYPES = {
    0: 'simple',
    1: 'salted',
    3: 'iterated-salted',
}


def iter_to_fread(iter_str):
  data_ary, iter_str = [buffer('')], iter(iter_str)

  def fread(size):
    if size <= 0:
      return ''
    data = data_ary[0]
    result, data = data[:size], buffer(data, size)
    if len(result) < size:
      remaining = size - len(result)
      result = [result]
      while remaining > 0:
        try:
          data = buffer(iter_str.next())
        except StopIteration:
          break
        result.append(data[:remaining])
        data = buffer(data, len(result[-1]))
        remaining -= len(result[-1])
      result = ''.join(result)
    data_ary[0] = data
    return result

  return fread


def open_symmetric_gpg(f, passphrase):
  # https://tools.ietf.org/html/rfc4880
  # TODO(pts): Support the ASCII armor as well.
  is_prev_partial = False
  cipher_algo = session_key = None
  iter_packets = yield_gpg_packets(f)
  for packet_type, is_partial, data in iter_packets:
    break
  else:
    raise ValueError('EOF before SKESK packet.')
  # Symmetric-Key Encrypted Session Key Packet
  if packet_type != 3:
    raise ValueError('Expected SKESK packet type, got: %d' % packet_type)
  if not 4 <= len(data) <= 46:
    raise ValueError('Bad GPG symmetric encrypted data (bad SKESK packet size).')
  assert not is_partial
  version, cipher_algo, s2k_type, hash_algo = struct.unpack(
      '>BBBB', buffer(data, 0, 4))
  if version != 4:
    raise ValueError('SKESK version 4 expected, got %d' % version)
  i = 4
  if s2k_type == 0:
    salt, count = '', 0
  else:
    salt = data[i : i + 8]
    if len(salt) < 8:
      raise ValueError('EOF in SKESK salt.')
    i += 8
    if s2k_type == 3:
      if i >= len(data):
        raise ValueError('EOF in SKESK iterated-salted count.')
      b = ord(data[i])
      i += 1
      count = (16 + (b & 15)) << ((b >> 4) + 6)
    else:
      count = 0
  print >>sys.stderr, 'info: GPG symmetric cipher_algo=%s s2k_type=%s hash_algo=%s count=%d len(salt)=%d len(encrypted_session_key)=%d' % (
      CIPHER_ALGOS_ALL.get(cipher_algo, cipher_algo), S2K_TYPES.get(s2k_type, s2k_type), HASH_ALGOS.get(hash_algo, hash_algo), count, len(salt), len(data) - i)
  #print >>sys.stderr, 'SKESK cipher_algo=%s s2k_type=%s hash_algo=%s count=%d salt=%r encrypted_session_key=%r' % (
  #    CIPHER_ALGOS_ALL.get(cipher_algo, cipher_algo), S2K_TYPES.get(s2k_type, s2k_type), HASH_ALGOS.get(hash_algo, hash_algo), count, salt, data[i:])
  if cipher_algo not in CIPHER_ALGOS:
    raise ValueError('Unknown SKESK cipher_algo: %d' % cipher_algo)
  if s2k_type not in S2K_TYPES:
    raise ValueError('Unknown SKESK s2k_type: %d' % s2k_type)
  if hash_algo not in HASH_ALGOS:
    raise ValueError('Unknown SKESK hash_algo: %d' % hash_algo)
  digest_func, _ = tinyveracrypt.HASH_DIGEST_PARAMS[HASH_ALGOS[hash_algo]]
  keytable_size = KEYTABLE_SIZES[cipher_algo]
  for packet_type, is_partial, data2 in iter_packets:
    break
  else:
    raise ValueError('EOF after SKESK packet.')
  if packet_type == 9:
    has_mdc = False
    data_ary = [(is_partial, data2)]
  elif packet_type == 18:
    has_mdc = True
    if not data2:
      raise ValueError('Integrity-protected packet too short.')
    version = ord(data2[0])
    if version != 1:
      raise ValueError('Integrity-protected packet version 1 expected, got: %d' % version)
    data_ary = [(is_partial, data2[1:])]
  else:
    raise ValueError('Expected symmetric data packet type, got: %d' % packet_type)
  del data2

  # Calculate session key.
  # https://github.com/mitchellrj/python-pgp/blob/master/pgp/s2k.py
  session_key = []
  session_key_remaining = keytable_size
  sp = salt + passphrase
  del passphrase
  if count <= len(sp):
    count = len(sp)
  while session_key_remaining > 0:
    d, c = digest_func('\0' * len(session_key)), count
    while c > len(sp):
      d.update(sp)
      c -= len(sp)
    d.update(sp[:c])
    session_key.append(d.digest())
    session_key_remaining -= len(session_key[-1])
  session_key = ''.join(session_key)[:keytable_size]
  assert len(session_key) == keytable_size
  del keytable_size, salt, sp
  # Correct, same as:
  # gpg --list-packets -vvvvv --show-session-key --pinentry-mode loopback hellow4.bin.gpg
  #print 'SKESK session_key=%r' % (session_key.encode('hex').upper(),)

  if len(data) > i:  # Encrypted session key.
    if s2k_type == 0:
      raise ValueError('Encrypted session key needs salt.')
    strxor_16 = tinyveracrypt.make_strxor(16)  # For AES block size.
    codebook = tinyveracrypt.new_aes(session_key)
    encrypt_func = codebook.encrypt
    fre = encrypt_func('\0' * 16)
    session_key = []
    for i in xrange(i, len(data), 16):
      datae = data[i : i + 16]
      data1 = strxor_16(datae + '\0' * (16 - len(datae)), fre)[:len(datae)]
      if session_key:
        session_key.append(data1)
      else:
        cipher_algo = ord(data1[0])
        if cipher_algo not in CIPHER_ALGOS:
          raise ValueError('Unknown encrypted session key cipher_algo: %d' % cipher_algo)
        session_key.append(data1[1:])
      if len(datae) < 16:
        break
      fre = encrypt_func(datae)
    session_key = ''.join(session_key)
    if len(session_key) != KEYTABLE_SIZES[cipher_algo]:
      raise ValueError('Encrypted session key size must be %d for cipher_algo %s, got: %d' %
                       (KEYTABLE_SIZES[cipher_algo], CIPHER_ALGOS[cipher_algo], len(session_key)))

  def yield_data_chunks():
    if data_ary:
      is_partial, data = data_ary.pop()
      yield data
      is_done = not is_partial
    for packet_type2, is_partial, data in iter_packets:
      if is_done:
        raise ValueError('Unexpected packet after symmetric data: %d' %
                         packet_type2)
      yield data
      is_done = not is_partial
    if not is_done:
      raise ValueError('Last packet must be a non-partial packet.')

  return cipher_algo, session_key, has_mdc, iter_to_fread(yield_data_chunks())


class BadPassphraseError(ValueError):
  """Raised when a bad passphrase is detected early at decryption."""


def decrypt_symmetric_gpg(fread, of, passphrase):
  cipher_algo, session_key, has_mdc, fread = open_symmetric_gpg(
      fread, passphrase)
  del passphrase
  #print (cipher_algo, session_key, has_mdc)
  strxor_16 = tinyveracrypt.make_strxor(16)  # For AES block size.
  strxor_2 = tinyveracrypt.make_strxor(2)
  codebook = tinyveracrypt.new_aes(session_key)
  encrypt_func = codebook.encrypt
  fre = encrypt_func('\0' * 16)
  data = fread(16)
  if len(data) != 16:
    raise ValueError('EOF in block 0.')
  data1 = strxor_16(data, fre)
  fre = encrypt_func(data)
  queue = []
  if has_mdc:
    mdc_obj = tinyveracrypt.HASH_DIGEST_PARAMS['sha1'][0](data1)
    exp2 = data1[-2:]
    data = fread(16)
    if len(data) != 16:  # Always true, encrypted data includes 22 bytes of MDC packet.
      raise ValueError('EOF in block 1.')
    data1 = strxor_16(data, fre)
    if data1[:2] != exp2:  # We don't detect bad passphrase with P = 1./2**16.
      raise BadPassphraseError('Bad passphrase (MDC repeat).')
    queue.append(data1)
    data1 = data1[2:]
  else:
    exp2 = strxor_2(fre[:2], data1[-2:])
    got2 = fread(2)
    if len(got2) != 2:
      raise ValueError('EOF in block got2.')
    if exp2 != got2:  # We don't detect bad passphrase with P = 1./2**16.
      raise BadPassphraseError('Bad passphrase (non-MDC repeat).')
    fre = encrypt_func(data[2:] + got2)
    data = fread(16)
    # On empty plaintext, len(data) == 8 here.
    if len(data) < 2:
      raise ValueError('EOF in block 1.')
    data1 = strxor_16(data + '\0' * (16 - len(data)), fre)[:len(data)]
    mdc_obj = None
  # By doing these checks we decrease the P above by better than /2**5.
  if data1[0] == '\xa3':  # Indeterminate, packet_type == 8.
    if ord(data1[1]) >= 0x20:  # GPG 2.1.18 has 0..3 defined.
      raise ValueError('Bad passphrase (invalid compress_algo).')
    compress_algo = ord(data1[1])
    data1 = data1[2:]
  else:
    if has_mdc and data1.startswith('\xd3\x14'):
      pass  # MDC without any literal packet.
    elif data1[0] in '\xac\xad\xae\xcb':
      pass  # Literal packet, non-indeterminate.
    else:
      raise BadPassphraseError('Bad passphrase (bad packet type).')
    compress_algo = 0  # Uncompressed.
  if compress_algo == 0:
    zd = None  # Uncompressed.
  elif compress_algo == 1:
    import zlib  # ImportError: no flate decompressor in Python.
    zd = zlib.decompressobj(-13)
  elif compress_algo == 2:
    import zlib  # ImportError: no flate decompressor in Python.
    zd = zlib.decompressobj()
  elif compress_algo == 3:
    import bz2  # ImportError: no bzip2 decompressor in Python.
    zd = bz2.BZ2Decompressor()
  else:
    raise ValueError('Unknown compress_algo: %d' % compress_algo)

  def yield_data_chunks(data1, data):
    if zd:
      data1 = zd.decompress(data1)  # Can raise zlib.error.
    yield data1
    if len(data) == 16:
      while 1:
        fre = encrypt_func(data)
        data = fread(16)
        if len(data) < 16:
          data1 = strxor_16(data + '\0' * (16 - len(data)), fre)[:len(data)]
          if mdc_obj:
            queue.append(data1)
          if zd:
            try:
              data1 = zd.decompress(data1)
            except EOFError:  # By bz2.BZ2Decompressor.
              data1 = ''
          yield data1
          break
        data1 = strxor_16(data, fre)
        if mdc_obj:
          queue.append(data1)
          if len(queue) > 2:  # 2 * 16 - 2 >= 22.
            mdc_obj.update(queue.pop(0))
        if zd:  # TODO(pts): Do larger buffering. Does it speed it up?
          try:
            data1 = zd.decompress(data1)
          except EOFError:  # By bz2.BZ2Decompressor.
            data1 = ''
        yield data1
    if zd:
      if getattr(zd, 'flush', None):
        data1 = zd.flush()
      yield data1
      # Ignore zd.unused_data (22 bytes of mdc).
      # !! Don't even zd.decompress these last 22 bytes, skip EOFError above.

  fread2 = iter_to_fread(yield_data_chunks(data1, data))
  done_state, mdc = 0, None
  for packet_type, is_partial, data in yield_gpg_binary_packets(fread2):
    if done_state in (0, 2) and packet_type == 19 and has_mdc:  # MDC.
      if len(data) != 20:
        raise ValueError('MDC size must be 20, got: %d' % len(data))
      mdc = data
      done_state = 3
      continue
    if done_state in (2, 3):
      raise ValueError('Unexpected packet after literal data: %d' %
                       packet_type)
    if packet_type != 11:
      raise ValueError('Literal packet expected.')
    if done_state == 0:
      if len(data) < 6:
        raise ValueError('First literal packet too short.')
      literal_type, filename_size = struct.unpack('>cB', data[:2])
      if literal_type not in 'btul1':
        raise ValueError('Bad literal type: %r' % literal_type)
      if len(data) < 6 + filename_size:
        raise ValueError('First literal packet too short for filename.')
      # First we get filename, then the date (4 bytes), 4 byte Unix timestamp.
      data = data[6 + filename_size:]
    of.write(data)
    done_state = 1 + (not is_partial)
  if done_state not in (2, 3):
    raise ValueError('Missing last literal packet.')
  if has_mdc:
    queue = ''.join(queue)
    if len(queue) < 22 or queue[-22 : -20] != '\xd3\x14':
      raise ValueError('Missing MDC packet.')
    mdc = queue[-20:]
    mdc_obj.update(queue[:-20])
    if mdc_obj.digest() != mdc:
      raise ValueError('MDC mismatch, message may be tampered with.')


def main(argv):
  of = sys.stdout
  if len(argv) > 1:
    passphrase = argv[1]
  else:
    passphrase = tinyveracrypt.prompt_passphrase(False)
  decrypt_symmetric_gpg(sys.stdin.read, sys.stdout, passphrase)


if __name__ == '__main__':
  sys.exit(main(sys.argv))
