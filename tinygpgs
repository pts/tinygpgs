#! /usr/bin/python
# by pts@fazekas.hu at Thu Nov 28 22:09:47 CET 2019
#
# Simple Python 2.x tool to decrypt OpenPGP data encrypted with symmetric
# key (output of `gpg -c' and `gpg --symmetric'), using crypto in PyCrypto,
# only CAST5 and AES ciphers are supported.
#
# OpenPGP is defined in https://tools.ietf.org/html/rfc4880
#
# !! Add encryption (-c) support.
# !! Add Python 3 support.
# !! Add shebang, help and docs.
#

import struct
import sys

# --- Passphrase prompt.


def prompt_passphrase(do_passphrase_twice):
  sys.stderr.flush()
  sys.stdout.flush()
  import getpass
  passphrase = getpass.getpass('Enter passphrase: ')
  if not passphrase:
    raise SystemExit('empty passphrase')
  if do_passphrase_twice:
    passphrase2 = getpass.getpass('Re-enter passphrase: ')
    if passphrase != passphrase2:
      raise SystemExit('passphrases do not match')
  return passphrase


# --- strxor.

try:
  __import__('Crypto.Util.strxor')
  def make_strxor(size, strxor=sys.modules['Crypto.Util.strxor'].strxor):
    return strxor
except ImportError:
  try:
    bytearray  # Introduced in Python 2.6. Raises NameError in older Python.
    # This is about 26.18% faster than the one below using pack.
    #
    # Using array.array('B', ...) would be a bit slower than using pack.
    def make_strxor(size):
      def strxor(a, b, izip=itertools.izip, ba=bytearray, st=str):
        return st(ba((a ^ b for a, b in izip(ba(a), ba(b)))))
      return strxor
  except NameError:
    # This is the naive implementation, it's too slow:
    #
    # def strxor(a, b, izip=itertools.izip):
    #   return ''.join(chr(ord(x) ^ ord(y)) for x, y in izip(a, b))
    #
    # 58 times slower pure Python implementation, see
    # http://stackoverflow.com/a/19512514/97248
    def make_strxor(size):
      def strxor(a, b, izip=itertools.izip, pack=struct.pack, unpack=struct.unpack, fmt='%dB' % size):
        return pack(fmt, *(a ^ b for a, b in izip(unpack(fmt, a), unpack(fmt, b))))
      return strxor


# --- Hashes (message digests, MDCs).

def new_hash(hash, data=''):
  import hashlib
  return hashlib.new(hash, data)


# --- GPG.


def yield_gpg_binary_packets(fread, c0=''):
  while 1:
    if not c0:
      c0 = fread(1)
    if not c0:
      break
    b, c0 = ord(c0), ''
    if not b & 128:
      raise ValueError('Tag bit 7 expected.')
    if b & 64:  # New-format packet.
      packet_type = b & 63
      if packet_type == 0:
        raise ValueError('Packet type must not be 0.')
      c = fread(1)
      if not c:
        raise ValueError('EOF in new packet size byte 0.')
      b = ord(c)
      if 224 + 9 <= b < 255:
        while 1:
          remaining, is_partial = 1 << (b & 31), True
          while remaining > 0:
            size = min(remaining, 8192)  # Avoid large partial packets.
            data = fread(size)
            if len(data) != size:
              raise ValueError('EOF in partial packet.')
            yield packet_type, is_partial, data
            remaining -= size
          c = fread(1)
          if not c:
            raise ValueError('EOF in after-partial size byte 0.')
          b = ord(c)
          if not 224 <= b < 255:
            break
      if b < 191:
        size = b
      elif b < 224:
        c = fread(1)
        if not c:
          raise ValueError('EOF in new packet size byte 1.')
        size = ((b - 192) << 8 | ord(c)) + 192
      elif b < 255:
        # >= 512 bytes needed.
        raise ValueError('First partial body too short.')
      else:
        c = fread(4)
        if len(c) < 4:
          raise ValueError('EOF in new packet size byte 5.')
        size, = struct.unpack('>L', c)
    else:  # Old-format packet.
      packet_type = (b & 63) >> 2
      if packet_type == 0:
        raise ValueError('Packet type must not be 0.')
      lt = b & 3
      if lt == 0:
        c = fread(1)
        if not c:
          raise ValueError('EOF in old packet size 0.')
        size = ord(c)
      elif lt == 1:
        c = fread(2)
        if len(c) < 2:
          raise ValueError('EOF in old packet size 1.')
        size, = struct.unpack('>H', c)
      elif lt == 2:
        c = fread(4)
        if len(c) < 4:
          raise ValueError('EOF in old packet size 2.')
        size, = struct.unpack('>L', c)
      elif lt == 3:
        raise ValueError('Indeterminate packet size not supported.')
      else:
        raise ValueError('Unknown old packet tag: %d' % lt)
    if size:
      if packet_type in (9, 11, 18):
        if size > 8192:
          remaining, is_partial = (size - 8192) & ~8191, True
          while remaining > 0:
            size2 = min(remaining, 8192)
            data = fread(size2)
            if len(data) != size2:
              raise ValueError('EOF in partial packet.')
            yield packet_type, is_partial, data
            remaining -= size2
            size -= size2
        assert 0 < size <= 8192
      elif size > 46:
        # We could easily handle megabytes, but the output of `gpg
        # --symmetric' just doesn't have such packets.
        raise ValueError('Packet size unusually large: type %d, size %d' %
                         (packet_type, size))
      data = fread(size)
      if len(data) < size:
        raise ValueError('EOF in packet, type %d' % packet_type)
      is_partial = False
      yield packet_type, is_partial, data


CRC24_TABLE = (
    0x000000, 0x864cfb, 0x8ad50d, 0x0c99f6, 0x93e6e1, 0x15aa1a, 0x1933ec,
    0x9f7f17, 0xa18139, 0x27cdc2, 0x2b5434, 0xad18cf, 0x3267d8, 0xb42b23,
    0xb8b2d5, 0x3efe2e, 0xc54e89, 0x430272, 0x4f9b84, 0xc9d77f, 0x56a868,
    0xd0e493, 0xdc7d65, 0x5a319e, 0x64cfb0, 0xe2834b, 0xee1abd, 0x685646,
    0xf72951, 0x7165aa, 0x7dfc5c, 0xfbb0a7, 0x0cd1e9, 0x8a9d12, 0x8604e4,
    0x00481f, 0x9f3708, 0x197bf3, 0x15e205, 0x93aefe, 0xad50d0, 0x2b1c2b,
    0x2785dd, 0xa1c926, 0x3eb631, 0xb8faca, 0xb4633c, 0x322fc7, 0xc99f60,
    0x4fd39b, 0x434a6d, 0xc50696, 0x5a7981, 0xdc357a, 0xd0ac8c, 0x56e077,
    0x681e59, 0xee52a2, 0xe2cb54, 0x6487af, 0xfbf8b8, 0x7db443, 0x712db5,
    0xf7614e, 0x19a3d2, 0x9fef29, 0x9376df, 0x153a24, 0x8a4533, 0x0c09c8,
    0x00903e, 0x86dcc5, 0xb822eb, 0x3e6e10, 0x32f7e6, 0xb4bb1d, 0x2bc40a,
    0xad88f1, 0xa11107, 0x275dfc, 0xdced5b, 0x5aa1a0, 0x563856, 0xd074ad,
    0x4f0bba, 0xc94741, 0xc5deb7, 0x43924c, 0x7d6c62, 0xfb2099, 0xf7b96f,
    0x71f594, 0xee8a83, 0x68c678, 0x645f8e, 0xe21375, 0x15723b, 0x933ec0,
    0x9fa736, 0x19ebcd, 0x8694da, 0x00d821, 0x0c41d7, 0x8a0d2c, 0xb4f302,
    0x32bff9, 0x3e260f, 0xb86af4, 0x2715e3, 0xa15918, 0xadc0ee, 0x2b8c15,
    0xd03cb2, 0x567049, 0x5ae9bf, 0xdca544, 0x43da53, 0xc596a8, 0xc90f5e,
    0x4f43a5, 0x71bd8b, 0xf7f170, 0xfb6886, 0x7d247d, 0xe25b6a, 0x641791,
    0x688e67, 0xeec29c, 0x3347a4, 0xb50b5f, 0xb992a9, 0x3fde52, 0xa0a145,
    0x26edbe, 0x2a7448, 0xac38b3, 0x92c69d, 0x148a66, 0x181390, 0x9e5f6b,
    0x01207c, 0x876c87, 0x8bf571, 0x0db98a, 0xf6092d, 0x7045d6, 0x7cdc20,
    0xfa90db, 0x65efcc, 0xe3a337, 0xef3ac1, 0x69763a, 0x578814, 0xd1c4ef,
    0xdd5d19, 0x5b11e2, 0xc46ef5, 0x42220e, 0x4ebbf8, 0xc8f703, 0x3f964d,
    0xb9dab6, 0xb54340, 0x330fbb, 0xac70ac, 0x2a3c57, 0x26a5a1, 0xa0e95a,
    0x9e1774, 0x185b8f, 0x14c279, 0x928e82, 0x0df195, 0x8bbd6e, 0x872498,
    0x016863, 0xfad8c4, 0x7c943f, 0x700dc9, 0xf64132, 0x693e25, 0xef72de,
    0xe3eb28, 0x65a7d3, 0x5b59fd, 0xdd1506, 0xd18cf0, 0x57c00b, 0xc8bf1c,
    0x4ef3e7, 0x426a11, 0xc426ea, 0x2ae476, 0xaca88d, 0xa0317b, 0x267d80,
    0xb90297, 0x3f4e6c, 0x33d79a, 0xb59b61, 0x8b654f, 0x0d29b4, 0x01b042,
    0x87fcb9, 0x1883ae, 0x9ecf55, 0x9256a3, 0x141a58, 0xefaaff, 0x69e604,
    0x657ff2, 0xe33309, 0x7c4c1e, 0xfa00e5, 0xf69913, 0x70d5e8, 0x4e2bc6,
    0xc8673d, 0xc4fecb, 0x42b230, 0xddcd27, 0x5b81dc, 0x57182a, 0xd154d1,
    0x26359f, 0xa07964, 0xace092, 0x2aac69, 0xb5d37e, 0x339f85, 0x3f0673,
    0xb94a88, 0x87b4a6, 0x01f85d, 0x0d61ab, 0x8b2d50, 0x145247, 0x921ebc,
    0x9e874a, 0x18cbb1, 0xe37b16, 0x6537ed, 0x69ae1b, 0xefe2e0, 0x709df7,
    0xf6d10c, 0xfa48fa, 0x7c0401, 0x42fa2f, 0xc4b6d4, 0xc82f22, 0x4e63d9,
    0xd11cce, 0x575035, 0x5bc9c3, 0xdd8538,
)


def crc24(data, crc=0xb704ce):
  if not isinstance(data, (str, buffer)):
    raise TypeError
  table = CRC24_TABLE
  for c in data:
    crc = (table[((crc >> 16) ^ ord(c)) & 0xff] ^ (crc << 8)) & 0x00ffffff
  return crc


def str_to_fread(data):
  if not isinstance(data, (str, buffer)):
    raise TypeError
  i_ary = [0]

  def fread(size):
    i = i_ary[0]
    result = data[i : i + size]
    i_ary[0] = i + len(result)
    return result

  return fread


def get_gpg_ascii_armor_fread(fread):
  import binascii  # For base64.

  def yield_data_chunks(_a2b=binascii.a2b_base64, _crc24=crc24):
    buf, is_in_header, crc = '\n', True, _crc24('')

    try:
      while 1:
        data = fread(512)  # Anything >= 1 works here.
        if not data:
          raise ValueError('EOF in GPG ASCII armor.')
        data = data.replace('\r', '')
        if not data:
          continue
        if is_in_header:  # Skip over header.
          if buf[-1:] == '\n' and data[0] == '\n':
            data, is_in_header = data[1:], False
          else:
            i = data.find('\n\n')
            if i >= 0:
              data, is_in_header = data[i + 2:], False
            else:
              buf = data[-1:]  # Keep last '\n', if any.
              continue
          buf = ''
        i = data.find('-')
        if i >= 0:
          buf += data[:i].replace('\n', '')
          data = data[i:]
          break
        buf += data.replace('\n', '')
        s = len(buf)
        if s > 12:
          t = (s - 9) & ~3  # Keep last 5 for checksum, keep 4 for last few bytes.
          i = buf.find('=')
          if 0 <= i < t:
            raise ValueError('Too much padding at end of GPG ASCII armor base64.')
          bdata, buf = _a2b(buf[:t]), buf[t:]
          crc = _crc24(bdata, crc)
          yield bdata
      if len(data) < 26:
        data += fread(26 - len(data))
      if not (data.startswith('-----END PGP MESSAGE-----') and data[25 : 26] in '\r\n'):
        raise ValueError('Bad end of GPG ASCII armor.')
      t = buf.rfind('=')
      if t <= 0:
        raise ValueError('Missing GPG ASCII armor checksum.')
      if len(buf) != t + 5:
        raise ValueError('GPG ASCII armor checksum must be 4 bytes.')
      expected_crc = _a2b(buf[t + 1:])
      expected_crc, = struct.unpack('>L', '\0' + expected_crc)
      if buf[t - 2 : t] == '==':
        i = t - 2
      elif buf[t - 1 : t] == '=':
        i = t - 1
      else:
        i = t
      if buf.find('=') != i:
        raise ValueError('Too much padding at end of GPG ASCII armor base64.')
      bdata = _a2b(buf[:t])
      crc = _crc24(bdata, crc)
      if crc != expected_crc:
        raise ValueError('GPG ASCII armor checksum mismatch.')
      if bdata:
        yield bdata
    except binascii.Error:
      raise ValueError('Bad GPG ASCII armor data base64.')

  return iter_to_fread(yield_data_chunks())


def yield_gpg_packets(fread):
  while 1:
    c = fread(1)
    if not c:
      raise ValueError('EOF before GPG data.')
    if not c.isspace():
      break
  if c == '-':
    data = fread(27)
    if not (len(data) == 27 and data.startswith('-----BEGIN PGP MESSAGE-----'[1:]) and data[26] in '\r\n'):
      raise ValueError('GPG ASCII armor expected.')
    fread = get_gpg_ascii_armor_fread(fread)
    c = fread(1)
    if not c:
      raise ValueError('Empty GPG ASCII armor data.')
  if c not in '\x8c\x8d\x8e\xc3':  # packet_type == 3 (SKESK).
    raise ValueError('Bad GPG symmetric encrypted data (SKESK packet expected).')
  for packet in yield_gpg_binary_packets(fread, c):
    yield packet


CIPHER_ALGOS = {
    #0: 'unencrypted',  # gpg(1) can't decrypt it either.
    2: '3des',  # With 192-bit key.
    3: 'cast5',  # With 128-bit key.
    4: 'blowfish',  # With 128-bit key, 16 rounds.
    7: 'aes-128',
    8: 'aes-192',
    9: 'aes-256',
}


# https://github.com/gpg/libgcrypt/blob/e5c4cf0efb8fd297963e6b4392ab98c41dbad536/src/gcrypt.h.in#L919
CIPHER_ALGOS_ALL = {
    0: 'unencrypted',  # gpg(1) can't decrypt it either.
    1: 'idea',
    2: '3des',  # With 192-bit key.
    3: 'cast5',  # With 128-bit key.
    4: 'blowfish',  # With 128-bit key, 16 rounds.
    5: 'safer-sk128',
    6: 'des-sk',
    7: 'aes-128',
    8: 'aes-192',
    9: 'aes-256',
    10: 'twofish-256',
    301: 'rc4',  # 'arcfour'.
    302: 'des',  # Single-key, 56-bit DES.
    303: 'twofish-128',
    304: 'serpent-128',
    305: 'serpent-192',
    306: 'serpent-256',
    307: 'rfc2268-ron-40',
    308: 'rfc2268-ron-128',
    309: 'rfc4269-seed',
    310: 'camellia-128',
    311: 'camellia-192',
    312: 'camellia-256',
    313: 'salsa20',
    314: 'salsa20-r12',
    315: 'rfc-5830-gost',  # GOST 28147-89.
    316: 'chacha20',
}

KEYTABLE_SIZES = {
    2: 24,
    3: 16,
    4: 16,
    7: 16,
    8: 24,
    9: 32,
}

HASH_ALGOS = {
    1: 'md5',
    2: 'sha1',
    3: 'ripemd160',
    8: 'sha256',
    9: 'sha384',
    10: 'sha512',
    11: 'sha224',
}

S2K_TYPES = {
    0: 'simple',
    1: 'salted',
    3: 'iterated-salted',
}

COMPRESS_ALGOS = {
    0: 'uncompressed',
    1: 'zip',
    2: 'zlib',
    3: 'bzip2',
}


def iter_to_fread(iter_str):
  data_ary, iter_str = [buffer('')], iter(iter_str)

  def fread(size):
    if size <= 0:
      return ''
    data = data_ary[0]
    result, data = data[:size], buffer(data, size)
    if len(result) < size:
      remaining = size - len(result)
      result = [result]
      while remaining > 0:
        try:
          data = buffer(iter_str.next())
        except StopIteration:
          break
        result.append(data[:remaining])
        data = buffer(data, len(result[-1]))
        remaining -= len(result[-1])
      result = ''.join(result)
    data_ary[0] = data
    return result

  return fread


def get_gpg_cipher(cipher_algo, keytable):
  """Returns (codebook, block_size)."""
  if KEYTABLE_SIZES[cipher_algo] != len(keytable):
    raise ValueError('Session key must be %d bytes for cipher_algo %s, got: %d' %
                     (KEYTABLE_SIZES[cipher_algo], CIPHER_ALGOS[cipher_algo], len(keytable)))
  # TODO(pts): Use MODE_CFB and MODE_OPENPGP for speed.
  #
  # The ciphers below (CAST5 and AES) cover the GPG defaults between 1.0.6
  # (2001-06-01) and 2.2.17 (2019-07-09); https://en.wikipedia.org/wiki/GNU_Privacy_Guard says that CAST5 has been the default
  # cipher since the beginning (GPGP 0.9.x, 1999) until <2.1.
  #
  # !! Add PyCrypto support for 'idea', 'twofish-256'. These
  #    are the remaining ones in the OpenPGP RFC.
  if cipher_algo == 2:
    import Crypto.Cipher._DES3
    return Crypto.Cipher._DES3.new(keytable), 8
  elif cipher_algo == 3:  # !! TODO(pts): Add Python implementation.
    import Crypto.Cipher._CAST
    return Crypto.Cipher._CAST.new(keytable), 8
  elif cipher_algo == 4:
    import Crypto.Cipher._Blowfish
    return Crypto.Cipher._Blowfish.new(keytable), 8
  elif cipher_algo in (7, 8, 9):  # TODO(pts): Use Crypto.Cipher._AES.new(keytable), if available.
    import Crypto.Cipher._AES
    return Crypto.Cipher._AES.new(keytable), 16
  else:
    raise ValueError('Unsupported cipher_algo: %s' % CIPHER_ALGOS[cipher_algo])


def open_symmetric_gpg(f, passphrase):
  # https://tools.ietf.org/html/rfc4880
  # TODO(pts): Support the ASCII armor as well.
  is_prev_partial = False
  cipher_algo = session_key = None
  iter_packets = yield_gpg_packets(f)
  for packet_type, is_partial, data in iter_packets:
    break
  else:
    raise ValueError('EOF before SKESK packet.')
  # Symmetric-Key Encrypted Session Key Packet
  if packet_type != 3:
    raise ValueError('Expected SKESK packet type, got: %d' % packet_type)
  if not 4 <= len(data) <= 46:
    raise ValueError('Bad GPG symmetric encrypted data (bad SKESK packet size).')
  assert not is_partial
  version, cipher_algo, s2k_type, hash_algo = struct.unpack(
      '>BBBB', buffer(data, 0, 4))
  if version != 4:
    raise ValueError('SKESK version 4 expected, got %d' % version)
  i = 4
  if s2k_type == 0:
    salt, count = '', 0
  else:
    salt = data[i : i + 8]
    if len(salt) < 8:
      raise ValueError('EOF in SKESK salt.')
    i += 8
    if s2k_type == 3:
      if i >= len(data):
        raise ValueError('EOF in SKESK iterated-salted count.')
      b = ord(data[i])
      i += 1
      count = (16 + (b & 15)) << ((b >> 4) + 6)
    else:
      count = 0
  print >>sys.stderr, 'info: GPG symmetric cipher_algo=%s s2k_type=%s hash_algo=%s count=%d len(salt)=%d len(encrypted_session_key)=%d' % (
      CIPHER_ALGOS_ALL.get(cipher_algo, cipher_algo), S2K_TYPES.get(s2k_type, s2k_type), HASH_ALGOS.get(hash_algo, hash_algo), count, len(salt), len(data) - i)
  #print >>sys.stderr, 'SKESK cipher_algo=%s s2k_type=%s hash_algo=%s count=%d salt=%r encrypted_session_key=%r' % (
  #    CIPHER_ALGOS_ALL.get(cipher_algo, cipher_algo), S2K_TYPES.get(s2k_type, s2k_type), HASH_ALGOS.get(hash_algo, hash_algo), count, salt, data[i:])
  if cipher_algo not in CIPHER_ALGOS:
    raise ValueError('Unknown SKESK cipher_algo: %d' % cipher_algo)
  if s2k_type not in S2K_TYPES:
    raise ValueError('Unknown SKESK s2k_type: %d' % s2k_type)
  if hash_algo not in HASH_ALGOS:
    raise ValueError('Unknown SKESK hash_algo: %d' % hash_algo)
  digest_func = lambda data='': new_hash(HASH_ALGOS[hash_algo], data)
  keytable_size = KEYTABLE_SIZES[cipher_algo]
  for packet_type, is_partial, data2 in iter_packets:
    break
  else:
    raise ValueError('EOF after SKESK packet.')
  if packet_type == 9:
    has_mdc = False
    data_ary = [(is_partial, data2)]
  elif packet_type == 18:
    has_mdc = True
    if not data2:
      raise ValueError('Integrity-protected packet too short.')
    version = ord(data2[0])
    if version != 1:
      raise ValueError('Integrity-protected packet version 1 expected, got: %d' % version)
    data_ary = [(is_partial, data2[1:])]
  else:
    raise ValueError('Expected symmetric data packet type, got: %d' % packet_type)
  del data2

  # Calculate session key.
  # https://github.com/mitchellrj/python-pgp/blob/master/pgp/s2k.py
  session_key = []
  session_key_remaining = keytable_size
  sp = salt + passphrase
  del passphrase
  if count <= len(sp):
    count = len(sp)
  while session_key_remaining > 0:
    d, c = digest_func('\0' * len(session_key)), count
    if c >> 16:  # Speedup: run little Python code only.
      cx = (1 << 16) // len(sp)
      spx = sp * cx  # At most 64 KiB of memory use.
      while c >= len(spx):
        d.update(spx)
        c -= len(spx)
      assert not c >> 16
    d.update(sp * (c // len(sp)))  # At most 64 KiB.
    d.update(sp[:c % len(sp)])
    session_key.append(d.digest())
    session_key_remaining -= len(session_key[-1])
  session_key = ''.join(session_key)[:keytable_size]
  assert len(session_key) == keytable_size
  del keytable_size, salt, sp
  # Correct, same as:
  # gpg --list-packets -vvvvv --show-session-key --pinentry-mode loopback hellow4.bin.gpg
  #print 'SKESK session_key=%r' % (session_key.encode('hex').upper(),)

  if len(data) > i:  # Encrypted session key.
    if s2k_type == 0:
      raise ValueError('Encrypted session key needs salt.')
    codebook, bs = get_gpg_cipher(cipher_algo, session_key)
    strxor_bs = make_strxor(bs)  # For cipher_algo block size.
    encrypt_func = codebook.encrypt
    fre = encrypt_func('\0' * bs)
    session_key = []
    for i in xrange(i, len(data), bs):
      datae = data[i : i + bs]
      data1 = strxor_bs(datae + '\0' * (bs - len(datae)), fre)[:len(datae)]
      if session_key:
        session_key.append(data1)
      else:
        cipher_algo = ord(data1[0])
        if cipher_algo not in CIPHER_ALGOS:
          raise ValueError('Unknown encrypted session key cipher_algo: %d' % cipher_algo)
        session_key.append(data1[1:])
      if len(datae) < bs:
        break
      fre = encrypt_func(datae)
    session_key = ''.join(session_key)
    if len(session_key) != KEYTABLE_SIZES[cipher_algo]:
      raise ValueError('Encrypted session key size must be %d for cipher_algo %s, got: %d' %
                       (KEYTABLE_SIZES[cipher_algo], CIPHER_ALGOS[cipher_algo], len(session_key)))

  def yield_data_chunks():
    if data_ary:
      is_partial, data = data_ary.pop()
      yield data
      is_done = not is_partial
    for packet_type2, is_partial, data in iter_packets:
      if is_done:
        raise ValueError('Unexpected packet after symmetric data: %d' %
                         packet_type2)
      yield data
      is_done = not is_partial
    if not is_done:
      raise ValueError('Last packet must be a non-partial packet.')

  return cipher_algo, session_key, has_mdc, iter_to_fread(yield_data_chunks())


class BadPassphraseError(ValueError):
  """Raised when a bad passphrase is detected early at decryption."""


def decrypt_symmetric_gpg(fread, of, passphrase):
  cipher_algo, session_key, has_mdc, fread = open_symmetric_gpg(
      fread, passphrase)
  del passphrase
  print >>sys.stderr, 'info: GPG symmetric session has_mdc=%d cipher_algo=%s len(session_key)=%d' % (
      int(has_mdc), CIPHER_ALGOS_ALL.get(cipher_algo, cipher_algo), len(session_key))
  #print (cipher_algo, session_key, has_mdc)
  strxor_2 = make_strxor(2)
  codebook, bs = get_gpg_cipher(cipher_algo, session_key)
  strxor_bs = make_strxor(bs)  # For cipher_algo block size.
  encrypt_func = codebook.encrypt
  fre = encrypt_func('\0' * bs)
  data = fread(bs)
  if len(data) != bs:
    raise ValueError('EOF in block 0.')
  data1 = strxor_bs(data, fre)
  fre = encrypt_func(data)
  if has_mdc:
    exp2 = data1[-2:]
    data = fread(bs)
    if len(data) != bs:  # Always true, encrypted data includes 22 bytes of MDC packet.
      raise ValueError('EOF in block 1.')
    mdc_obj = new_hash('sha1', data1)
    mdc_obj.update(exp2)
    data1 = strxor_bs(data, fre)
    if data1[:2] != exp2:  # We don't detect bad passphrase with P = 1./2**bs.
      raise BadPassphraseError('Bad passphrase (MDC repeat).')
    data1 = data1[2:]
    mdc_queue = []
    # Number of blocks to which 22 + 4 bytes fit. See below why.
    mdc_min_queue_size = (22 + 4 + bs - 1) // bs
  else:
    exp2 = strxor_2(fre[:2], data1[-2:])
    got2 = fread(2)
    if len(got2) != 2:
      raise ValueError('EOF in block got2.')
    if exp2 != got2:  # We don't detect bad passphrase with P = 1./2**bs.
      raise BadPassphraseError('Bad passphrase (non-MDC repeat).')
    fre = encrypt_func(data[2:] + got2)
    data = fread(bs)
    # On empty plaintext, len(data) == 8 here.
    if len(data) < 2:
      raise ValueError('EOF in block 1.')
    data1 = strxor_bs(data + '\0' * (bs - len(data)), fre)[:len(data)]
    mdc_obj = None
  # By doing these checks we decrease the P above by better than /2**5.
  if data1[0] == '\xa3':  # Indeterminate, packet_type == 8.
    if ord(data1[1]) >= 0x20:  # GPG 2.1.18 has 0..3 defined.
      raise ValueError('Bad passphrase (invalid compress_algo).')
    compress_algo = ord(data1[1])
    if mdc_obj:
      mdc_obj.update(data1[:2])
    data1 = data1[2:]
  else:
    if mdc_obj and data1.startswith('\xd3\x14'):
      pass  # MDC without any literal packet.
    elif data1[0] in '\xac\xad\xae\xcb':
      pass  # Literal packet, non-indeterminate.
    else:
      raise BadPassphraseError('Bad passphrase (bad packet type).')
    compress_algo = 0  # Uncompressed.
  print >>sys.stderr, 'info: GPG symmetric compress_algo=%s' % (
      COMPRESS_ALGOS.get(compress_algo, compress_algo))
  if compress_algo == 0:
    zd = None  # Uncompressed.
  elif compress_algo == 1:
    import zlib  # ImportError: no flate decompressor in Python.
    zd = zlib.decompressobj(-13)
  elif compress_algo == 2:
    import zlib  # ImportError: no flate decompressor in Python.
    zd = zlib.decompressobj()
  elif compress_algo == 3:
    import bz2  # ImportError: no bzip2 decompressor in Python.
    zd = bz2.BZ2Decompressor()
  else:
    raise ValueError('Unknown compress_algo: %d' % compress_algo)
  if mdc_obj:
    # We don't process data1 yet, because we want to remove the MDC packet
    # (22 bytes, packet_type == 19, starts with '\xd3\x14') from the end first.
    mdc_queue.append(data1)
    data1 = ''

  def yield_data_chunks(data1, data):
    if zd:
      data1 = zd.decompress(data1)  # Can raise zlib.error.
    yield data1
    data1 = ''
    if len(data) == bs:
      while 1:
        fre = encrypt_func(data)
        data = fread(bs)
        if len(data) < bs:
          data1 = strxor_bs(data + '\0' * (bs - len(data)), fre)[:len(data)]
          break
        data1 = strxor_bs(data, fre)
        if mdc_obj:
          if len(mdc_queue) >= mdc_min_queue_size:
            data2 = mdc_queue.pop(0)
            mdc_obj.update(data2)
            if zd:
              data2 = zd.decompress(data2)
            yield data2
          mdc_queue.append(data1)
          # Now len(mdc_queue) >= min_queue_size, and it contains enough
          # bytes (>= 22) for an MDC packet: mdc_min_queue_size * bs -
          # len(exp2) - len('\xd3\x14') >= 22.
        else:
          if zd:  # TODO(pts): Do larger buffering. Does it speed it up?
            data1 = zd.decompress(data1)
          yield data1
    # Now data1 is the last plaintext chunk to process.
    if mdc_obj:
      mdc_queue.append(data1)
      data1 = ''.join(mdc_queue)
      del mdc_queue[:]
      if len(data1) < 22:
        raise ValueError('EOF in encrypted data before MDC packet.')
      if data1[-22 : -20] != '\xd3\x14':  # packet_type == 19.
        raise ValueError('Bad MDC packet header.')
      data1, mdc = data1[:-22], data1[-20:]
      mdc_obj.update(data1)
      mdc_obj.update('\xd3\x14')
      if mdc_obj.digest() != mdc:
        raise ValueError('MDC mismatch, message may have been tampered with.')
    if zd:
      data1 = zd.decompress(data1)
    yield data1
    if zd and getattr(zd, 'flush', None):
      data1 = zd.flush()
      yield data1

  fread2 = iter_to_fread(yield_data_chunks(data1, data))
  done_state = 0
  for packet_type, is_partial, data in yield_gpg_binary_packets(fread2):
    if done_state == 2:
      raise ValueError('Unexpected packet after literal data: %d' %
                       packet_type)
    if packet_type != 11:
      raise ValueError('Literal packet expected.')
    if done_state == 0:
      if len(data) < 6:
        raise ValueError('First literal packet too short.')
      literal_type, filename_size = struct.unpack('>cB', data[:2])
      if literal_type not in 'btul1':
        raise ValueError('Bad literal type: %r' % literal_type)
      if len(data) < 6 + filename_size:
        raise ValueError('First literal packet too short for filename.')
      # First we get filename, then the date (4 bytes), 4 byte Unix timestamp.
      data = data[6 + filename_size:]
    of.write(data)
    done_state = 1 + (not is_partial)
  if done_state == 1:
    raise ValueError('Missing last literal packet.')


def main(argv):
  argv = list(argv)
  if len(argv) > 3 and argv[1] == '-d' and argv[2] == '--pinentry-mode' and argv[3] == 'loopback':
    del argv[2 : 4]
  if len(argv) not in (2, 3) or argv[1] != '-d':
    sys.stderr.write(
        'tinygpgs: decrypt symmetric encrypted GPG files\n'
        'usage: %s -d <INPUT.BIN.GPG >INPUT.BIN\n' % argv[0])
    sys.exit(1)
  if len(argv) > 2:
    passphrase = argv[2]
  else:
    passphrase = prompt_passphrase(False)
  decrypt_symmetric_gpg(sys.stdin.read, sys.stdout, passphrase)


if __name__ == '__main__':
  sys.exit(main(sys.argv))
